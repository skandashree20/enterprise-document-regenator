{
  "name": "21 - Document Updater",
  "nodes": [
    {
      "id": "trigger-node",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [
        0,
        0
      ],
      "parameters": {},
      "typeVersion": 1
    },
    {
      "id": "extract-topics",
      "name": "Extract Research Topics",
      "type": "n8n-nodes-base.code",
      "position": [
        220,
        0
      ],
      "parameters": {
        "jsCode": "// Extract key topics from document for targeted research\nconst item = $input.first().json;\nconst analysis = item.analysis || {};\nconst extractedText = item.extracted_text || '';\n\n// Build search queries based on document content\nconst searchTopics = [];\n\n// From analysis themes\nif (analysis.themes && analysis.themes.length > 0) {\n  searchTopics.push(...analysis.themes.slice(0, 3));\n}\n\n// From entities\nif (analysis.entities) {\n  if (analysis.entities.products) searchTopics.push(...analysis.entities.products.slice(0, 2));\n  if (analysis.entities.technologies) searchTopics.push(...analysis.entities.technologies.slice(0, 2));\n}\n\n// From compliance mentions\nif (analysis.edtech_relevance?.compliance_mentions) {\n  searchTopics.push(...analysis.edtech_relevance.compliance_mentions);\n}\n\n// Deduplicate and limit\nconst uniqueTopics = [...new Set(searchTopics)].slice(0, 5);\n\n// Generate search queries\nconst searchQueries = uniqueTopics.map(topic => {\n  // Add context for better search results\n  if (topic.toLowerCase().includes('ferpa')) return 'FERPA compliance updates 2024 2025';\n  if (topic.toLowerCase().includes('soc')) return 'SOC 2 compliance requirements updates';\n  if (topic.toLowerCase().includes('transcript')) return 'academic transcript processing technology updates';\n  if (topic.toLowerCase().includes('airr')) return 'AIRR transcript automation higher education';\n  return `${topic} higher education EdTech updates 2024 2025`;\n});\n\nreturn [{\n  json: {\n    file_id: item.file_id,\n    file_name: item.file_name,\n    original_text: extractedText,\n    analysis: analysis,\n    search_topics: uniqueTopics,\n    search_queries: searchQueries,\n    output_folder_id: item.output_folder_id || item.config?.output_folder_id || '',\n    research_started: new Date().toISOString()\n  }\n}];"
      },
      "typeVersion": 2
    },
    {
      "id": "prepare-searches",
      "name": "Prepare Search Requests",
      "type": "n8n-nodes-base.code",
      "position": [
        440,
        0
      ],
      "parameters": {
        "jsCode": "// Prepare search requests for each query\nconst item = $input.first().json;\nconst queries = item.search_queries || [];\n\nif (queries.length === 0) {\n  return [{\n    json: {\n      ...item,\n      search_results: [],\n      skip_reason: 'No search topics identified'\n    }\n  }];\n}\n\n// Return items for each search query\nreturn queries.map((query, index) => ({\n  json: {\n    query: query,\n    query_index: index,\n    parent_data: item\n  }\n}));"
      },
      "typeVersion": 2
    },
    {
      "id": "serper-search",
      "name": "Serper Search API",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        660,
        0
      ],
      "parameters": {
        "url": "https://google.serper.dev/search",
        "method": "POST",
        "options": {
          "timeout": 30000
        },
        "jsonBody": "={{ JSON.stringify({ q: $json.query, num: 5 }) }}",
        "sendBody": true,
        "specifyBody": "json",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "credentials": {
        "httpHeaderAuth": {
          "id": "kK1GI05nBZrYdskn",
          "name": "Serper API"
        }
      },
      "typeVersion": 4.2,
      "continueOnFail": true
    },
    {
      "id": "parse-search",
      "name": "Parse Search Results",
      "type": "n8n-nodes-base.code",
      "position": [
        880,
        0
      ],
      "parameters": {
        "jsCode": "// Parse Serper search results\nconst item = $input.first();\nconst parentData = item.json.parent_data || $('Prepare Search Requests').first().json.parent_data;\nconst query = item.json.query || item.json.parent_data?.query || '';\n\nlet results = [];\ntry {\n  // Serper returns organic results in 'organic' array\n  const organicResults = item.json.organic || [];\n  results = organicResults.slice(0, 3).map(r => ({\n    title: r.title || '',\n    description: r.snippet || r.description || '',\n    url: r.link || r.url || '',\n    date: r.date || ''\n  }));\n  \n  // Also check for knowledge graph or answer box\n  if (item.json.answerBox) {\n    results.unshift({\n      title: item.json.answerBox.title || 'Featured Answer',\n      description: item.json.answerBox.snippet || item.json.answerBox.answer || '',\n      url: item.json.answerBox.link || '',\n      date: ''\n    });\n  }\n} catch (e) {\n  results = [];\n}\n\nreturn [{\n  json: {\n    query: query,\n    results: results,\n    parent_data: parentData\n  }\n}];"
      },
      "typeVersion": 2
    },
    {
      "id": "aggregate-searches",
      "name": "Aggregate Search Results",
      "type": "n8n-nodes-base.aggregate",
      "position": [
        1100,
        0
      ],
      "parameters": {
        "options": {},
        "aggregate": "aggregateAllItemData",
        "destinationFieldName": "all_search_results"
      },
      "typeVersion": 1
    },
    {
      "id": "compile-research",
      "name": "Compile Research",
      "type": "n8n-nodes-base.code",
      "position": [
        1320,
        0
      ],
      "parameters": {
        "jsCode": "// Combine all search results with original document\nconst item = $input.first().json;\nconst allResults = item.all_search_results || [];\n\n// Get parent data from first result\nconst parentData = allResults[0]?.parent_data || {};\n\n// Compile all research findings\nconst researchFindings = allResults.map(r => ({\n  query: r.query,\n  findings: r.results || []\n})).filter(r => r.findings.length > 0);\n\n// Format findings as text for LLM\nlet findingsText = '';\nfor (const finding of researchFindings) {\n  findingsText += `\\n### Research: ${finding.query}\\n`;\n  for (const f of finding.findings) {\n    findingsText += `- **${f.title}**: ${f.description}\\n`;\n  }\n}\n\nreturn [{\n  json: {\n    file_id: parentData.file_id,\n    file_name: parentData.file_name,\n    original_text: parentData.original_text,\n    analysis: parentData.analysis,\n    search_topics: parentData.search_topics,\n    output_folder_id: parentData.output_folder_id,\n    research_findings: researchFindings,\n    research_findings_text: findingsText,\n    has_findings: researchFindings.length > 0\n  }\n}];"
      },
      "typeVersion": 2
    },
    {
      "id": "check-findings",
      "name": "Has Research Findings?",
      "type": "n8n-nodes-base.if",
      "position": [
        1540,
        0
      ],
      "parameters": {
        "options": {},
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "has-findings",
              "operator": {
                "type": "boolean",
                "operation": "equals"
              },
              "leftValue": "={{ $json.has_findings }}",
              "rightValue": true
            }
          ]
        }
      },
      "typeVersion": 2
    },
    {
      "id": "analyze-updates",
      "name": "Analyze & Generate Updates",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "position": [
        1760,
        -100
      ],
      "parameters": {
        "model": "gpt-4o",
        "options": {
          "maxTokens": 8000,
          "temperature": 0.3,
          "responseFormat": "json_object"
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a document update specialist for OneOrigin, an EdTech company. Your task is to:\n\n1. Compare the original document content with recent research findings\n2. Identify sections that are outdated or could benefit from updates\n3. Generate an updated version of the document incorporating new information\n\nGuidelines:\n- Preserve the original document structure and tone\n- Only update sections where new information adds value\n- Clearly mark what was updated with [UPDATED] tags\n- Add sources/references for new information\n- Focus on: compliance updates, technology changes, industry trends, best practices\n\nRespond with JSON containing:\n- needs_update: boolean\n- update_summary: brief description of changes\n- updated_sections: array of {section_name, original, updated, reason}\n- updated_document: full updated document text\n- sources: array of sources used"
            },
            {
              "role": "user",
              "content": "=Review this document and update it based on the research findings:\n\n## ORIGINAL DOCUMENT\nFile: {{ $json.file_name }}\n\n{{ $json.original_text.substring(0, 15000) }}\n\n---\n\n## RECENT RESEARCH FINDINGS\n{{ $json.research_findings_text }}\n\n---\n\nAnalyze the document, compare with research findings, and provide updates where relevant. If no updates are needed, set needs_update to false."
            }
          ]
        }
      },
      "credentials": {
        "openAiApi": {
          "id": "CJCFB3T7mvekmbpe",
          "name": "OpenAI API"
        }
      },
      "typeVersion": 1.8,
      "continueOnFail": true
    },
    {
      "id": "format-update",
      "name": "Format Update Result",
      "type": "n8n-nodes-base.code",
      "position": [
        1980,
        -100
      ],
      "parameters": {
        "jsCode": "// Parse update analysis and prepare output\nconst item = $input.first();\nconst originalData = $('Compile Research').first().json;\nlet updateResult = null;\n\ntry {\n  const response = item.json.message?.content || item.json.text || item.json.output || '';\n  updateResult = typeof response === 'string' ? JSON.parse(response) : response;\n} catch (e) {\n  updateResult = {\n    needs_update: false,\n    update_summary: 'Failed to parse update analysis',\n    error: e.message\n  };\n}\n\nconst needsUpdate = updateResult.needs_update === true;\nconst updatedContent = needsUpdate ? updateResult.updated_document : originalData.original_text;\n\nreturn [{\n  json: {\n    file_id: originalData.file_id,\n    file_name: originalData.file_name,\n    original_file_name: originalData.file_name,\n    needs_update: needsUpdate,\n    update_summary: updateResult.update_summary || 'No updates needed',\n    updated_sections: updateResult.updated_sections || [],\n    sources: updateResult.sources || [],\n    \n    // For upload\n    document_type: 'updated_document',\n    title: `Updated: ${originalData.file_name}`,\n    content: updatedContent,\n    file_name: needsUpdate \n      ? originalData.file_name.replace(/\\.[^/.]+$/, '') + '_updated_' + new Date().toISOString().split('T')[0] + '.md'\n      : null,\n    output_folder_id: originalData.output_folder_id,\n    \n    status: needsUpdate ? 'updated' : 'no_update_needed',\n    processed_at: new Date().toISOString()\n  }\n}];"
      },
      "typeVersion": 2
    },
    {
      "id": "no-findings",
      "name": "No Updates Available",
      "type": "n8n-nodes-base.code",
      "position": [
        1760,
        100
      ],
      "parameters": {
        "jsCode": "// No research findings - return original document unchanged\nconst item = $input.first().json;\n\nreturn [{\n  json: {\n    file_id: item.file_id,\n    file_name: item.file_name,\n    original_file_name: item.file_name,\n    needs_update: false,\n    update_summary: 'No relevant research findings to compare',\n    updated_sections: [],\n    sources: [],\n    \n    document_type: 'original_document',\n    title: item.file_name,\n    content: item.original_text,\n    file_name: null,\n    output_folder_id: item.output_folder_id,\n    \n    status: 'no_research_available',\n    processed_at: new Date().toISOString()\n  }\n}];"
      },
      "typeVersion": 2
    },
    {
      "id": "merge-output",
      "name": "Merge Output",
      "type": "n8n-nodes-base.merge",
      "position": [
        2200,
        0
      ],
      "parameters": {},
      "typeVersion": 3
    }
  ],
  "connections": {
    "Compile Research": {
      "main": [
        [
          {
            "node": "Has Research Findings?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Serper Search API": {
      "main": [
        [
          {
            "node": "Parse Search Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Update Result": {
      "main": [
        [
          {
            "node": "Merge Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Updates Available": {
      "main": [
        [
          {
            "node": "Merge Output",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Parse Search Results": {
      "main": [
        [
          {
            "node": "Aggregate Search Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Research Findings?": {
      "main": [
        [
          {
            "node": "Analyze & Generate Updates",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Updates Available",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Research Topics": {
      "main": [
        [
          {
            "node": "Prepare Search Requests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Search Requests": {
      "main": [
        [
          {
            "node": "Serper Search API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Search Results": {
      "main": [
        [
          {
            "node": "Compile Research",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Extract Research Topics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze & Generate Updates": {
      "main": [
        [
          {
            "node": "Format Update Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
